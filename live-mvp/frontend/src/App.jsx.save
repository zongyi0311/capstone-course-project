import { useEffect, useRef, useState } from "react";
import io from "socket.io-client";

const API = "http://localhost:8080";

export default function App() {
  const [roomId, setRoomId] = useState("demo");
  const [isHost, setIsHost] = useState(false);
  const [messages, setMessages] = useState([]);
  const [text, setText] = useState("");
  const [socket, setSocket] = useState(null);
  const [hearts, setHearts] = useState([]);
  const [err, setErr] = useState("");

  const videoRef = useRef(null);
  const audioRef = useRef(null); // ⬅️ 新增：播放器 for 音訊

  // 建立 Socket.IO 連線
  useEffect(() => {
    const s = io(API);
    setSocket(s);
    return () => s.disconnect();
  }, []);

  // 收到聊天室/愛心事件
  useEffect(() => {
    if (!socket) return;
    socket.on("chat", (msg) => setMessages((m) => [...m, msg]));
    socket.on("heart", ({ left }) => spawnHeart(left));
    socket.on("sys", (msg) =>
      setMessages((m) => [...m, { user: "system", text: msg }])
    );
  }, [socket]);

  // 本地漂浮愛心
  const spawnHeart = (left) => {
    const id = crypto.randomUUID ? crypto.randomUUID() : String(Math.random());
    setHearts((h) => [...h, { id, left }]);
    setTimeout(() => setHearts((h) => h.filter((x) => x.id !== id)), 1600);
  };

  // 進房（Socket.IO + LiveKit）
  const join = async () => {
    setErr("");
    try {
      if (!socket) throw new Error("Socket 尚未連線");

      socket.emit("joinRoom", { roomId, userId: isHost ? "Host" : "Viewer" });

      // 動態載入 LiveKit（新版以 Room().connect）
      const { Room, createLocalTracks } = await import("livekit-client");

      // 後端拿 token
      const { token, url } = await fetch(`${API}/rooms/${roomId}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          userId: isHost ? "host" : "viewer",
          displayName: isHost ? "Host" : "Viewer",
          isHost,
        }),
      }).then((r) => r.json());

      const room = new Room();
      await room.connect(url, token);

      if (isHost) {
        // 主播：先嘗試 視訊+音訊，失敗則降級為僅音訊
        let tracks = [];
        try {
          tracks = await createLocalTracks({ audio: true, video: true });
        } catch (e) {
          console.warn("video+audio 失敗，改為 audio-only：", e);
          tracks = await createLocalTracks({ audio: true, video: false });
          setErr("找不到攝影機或無權限，已以『僅音訊』開播。");
        }

        for (const t of tracks) await room.localParticipant.publishTrack(t);

        // 本地預覽（若沒有 video，就不顯示畫面）
        const vTrack = tracks.find((t) => t.kind === "video");
        if (vTrack && videoRef.current) {
          const ms = new MediaStream([vTrack.mediaStreamTrack]);
          videoRef.current.srcObject = ms;
        }
      } else {
        // 觀眾：訂閱遠端影像 + 聲音
        room.on("trackSubscribed", (track) => {
          if (track.kind === "video" && videoRef.current) {
            const ms = new MediaStream([track.mediaStreamTrack]);
            videoRef.current.srcObject = ms;
          }
          if (track.kind === "audio" && audioRef.current) {
            const ms = new MediaStream([track.mediaStreamTrack]);
            audioRef.current.srcObject = ms;
            audioRef.current.muted = false;
            audioRef.current.play().catch(() => {}); // 觸發自動播放
          }
        });
      }
    } catch (e) {
      console.error(e);
      setErr("Join 失敗：" + (e?.message || e));
    }
  };

  const send = () => {
    if (!text.trim() || !socket) return;
    socket.emit("chat", { roomId, user: isHost ? "Host" : "Viewer", text });
    setText("");
  };

  const onHeart = () => {
    if (!socket) return;
    const left = Math.random() * 80 + 10;
    socket.emit("heart", { roomId, left });
    spawnHeart(left);
  };

  return (
    <div style={{ padding: 16, position: "relative" }}>
      <style>{`
        @keyframes floatUp {
          0%   { transform: translateY(0) scale(0.9); opacity: 0; }
          10%  { opacity: 1; }
          100% { transform: translateY(-140px) scale(1.2); opacity: 0; }
        }
        .heart {
          position: absolute;
          bottom: 150px;
          font-size: 28px;
          animation: floatUp 1.6s ease-out forwards;
          pointer-events: none;
          user-select: none;
        }
      `}</style>

      <h3>Live MVP (LiveKit + Socket.IO)</h3>

      {err && (
        <div style={{ color: "white", background: "#d33", padding: 8, marginBottom: 8, borderRadius: 6 }}>
          {err}
        </div>
      )}

      <div style={{ display: "flex", gap: 8 }}>
        <input value={roomId} onChange={(e) => setRoomId(e.target.value)} placeholder="roomId" />
        <label>
          <input type="checkbox" checked={isHost} onChange={(e) => setIsHost(e.target.checked)} /> Host
        </label>
        <button onClick={join}>Join</button>
      </div>

      {/* 視訊顯示 */}
      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted={isHost}
        style={{ width: 480, height: 270, background: "#000", marginTop: 12, borderRadius: 6 }}
      />
      {/* 音訊播放（隱藏） */}
      <audio ref={audioRef} autoPlay playsInline style={{ display: "none" }} />

      {/* 飄心 */}
      {hearts.map((h) => (
        <div key={h.id} className="heart" style={{ left: `${h.left}%` }}>❤️</div>
      ))}

      {/* 聊天 */}
      <div style={{ marginTop: 12 }}>
        <input value={text} onChange={(e) => setText(e.target.value)} placeholder="message..." />
        <button onClick={send}>Send</button>
        <button onClick={onHeart}>❤️</button>
      </div>

      <div style={{ marginTop: 12, maxHeight: 180, overflow: "auto", border: "1px solid #ccc", padding: 8 }}>
        {messages.map((m, i) => (<div key={i}><b>{m.user}</b>: {m.text}</div>))}
      </div>
    </div>
  );
}

import { useEffect, useRef, useState } from "react";
import io from "socket.io-client";

const API = "http://localhost:8080";

export default function App() {
  const [roomId, setRoomId] = useState("demo");ㄜ  const [isHost, setIsHost] = useState(false);
  const [messages, setMessages] = useState([]);
  const [text, setText] = useState("");
  const [socket, setSocket] = useState(null);
  const [hearts, setHearts] = useState([]);
  const [err, setErr] = useState("");
  const videoRef = useRef(null);

  // 建立 Socket.IO 連線
  useEffect(() => {
    const s = io(API);
    setSocket(s);
    return () => s.disconnect();
  }, []);

  // 收到聊天室/愛心事件
  useEffect(() => {
    if (!socket) return;
    socket.on("chat", (msg) => setMessages((m) => [...m, msg]));
    socket.on("heart", ({ left }) => spawnHeart(left));
    socket.on("sys", (msg) =>
      setMessages((m) => [...m, { user: "system", text: msg }])
    );
  }, [socket]);

  // 本地漂浮愛心
  const spawnHeart = (left) => {
    const id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random());
    setHearts((h) => [...h, { id, left }]);
    setTimeout(() => setHearts((h) => h.filter((x) => x.id !== id)), 1600);
  };

  // 進房（Socket.IO + LiveKit）
  const join = async () => {
    setErr("");
    try {
      if (!socket) throw new Error("Socket 尚未連線");

      // 1) 加入聊天室房間（同步聊天/愛心）
      socket.emit("joinRoom", { roomId, userId: isHost ? "Host" : "Viewer" });

      // 2) 動態載入 LiveKit 並連線（新版需用 Room().connect）
      const { Room, createLocalTracks } = await import("livekit-client");

      // 向後端拿進房 token
      const { token, url } = await fetch(`${API}/rooms/${roomId}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          userId: isHost ? "host" : "viewer",
          displayName: isHost ? "Host" : "Viewer",
          isHost,
        }),
      }).then((r) => r.json());

      // 建立房間並連線
      const room = new Room();
      await room.connect(url, token);

      if (isHost) {
        // 主播：取得鏡頭/麥克風並發佈；本地預覽
        const tracks = await createLocalTracks({ audio: true, video: true });
        for (const t of tracks) await room.localParticipant.publishTrack(t);
        const ms = new MediaStream(tracks.map((t) => t.mediaStreamTrack));
        if (videoRef.current) videoRef.current.srcObject = ms;
      } else {
        // 觀眾：訂閱遠端影像
        room.on("trackSubscribed", (track) => {
          if (track.kind === "video") {
            const ms = new MediaStream([track.mediaStreamTrack]);
            if (videoRef.current) videoRef.current.srcObject = ms;
          }
        });
      }
    } catch (e) {
      console.error(e);
      setErr("Join 失敗：" + (e?.message || e));
    }
  };

  const send = () => {
    if (!text.trim() || !socket) return;
    socket.emit("chat", { roomId, user: isHost ? "Host" : "Viewer", text });
    setText("");
  };

  const onHeart = () => {
    if (!socket) return;
    const left = Math.random() * 80 + 10;
    socket.emit("heart", { roomId, left });
    spawnHeart(left);
  };

  return (
    <div style={{ padding: 16, position: "relative" }}>
      <style>{`
        @keyframes floatUp {
          0%   { transform: translateY(0) scale(0.9); opacity: 0; }
          10%  { opacity: 1; }
          100% { transform: translateY(-140px) scale(1.2); opacity: 0; }
        }
        .heart {
          position: absolute;
          bottom: 150px;
          font-size: 28px;
          animation: floatUp 1.6s ease-out forwards;
          pointer-events: none;
          user-select: none;
        }
      `}</style>

      <h3>Live MVP (LiveKit + Socket.IO)</h3>

      {err && (
        <div style={{ color: "white", background: "#d33", padding: 8, marginBottom: 8, borderRadius: 6 }}>
          {err}
        </div>
      )}

      <div style={{ display: "flex", gap: 8 }}>
        <input value={roomId} onChange={(e) => setRoomId(e.target.value)} placeholder="roomId" />
        <label>
          <input type="checkbox" checked={isHost} onChange={(e) => setIsHost(e.target.checked)} /> Host
        </label>
        <button onClick={join}>Join</button>
      </div>

      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted={isHost}
        style={{ width: 480, height: 270, background: "#000", marginTop: 12, borderRadius: 6 }}
      />

      {hearts.map((h) => (
        <div key={h.id} className="heart" style={{ left: `${h.left}%` }}>❤️</div>
      ))}

      <div style={{ marginTop: 12 }}>
        <input value={text} onChange={(e) => setText(e.target.value)} placeholder="message..." />
        <button onClick={send}>Send</button>
        <button onClick={onHeart}>❤️</button>
      </div>

      <div style={{ marginTop: 12, maxHeight: 180, overflow: "auto", border: "1px solid #ccc", padding: 8 }}>
        {messages.map((m, i) => (<div key={i}><b>{m.user}</b>: {m.text}</div>))}
      </div>
    </div>
  );
}
